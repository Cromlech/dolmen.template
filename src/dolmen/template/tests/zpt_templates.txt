Chameleon Zope page templates
=============================

Chameleon provides support for Zope page templates which can be used
from grok writing templates with the ``.cpt`` (=Chameleon Page
Template) filename extension.

Chameleon page templates differ from standard Zope page templates in a
few aspects, most notably:

* Expressions are parsed in ``Python-mode`` by default. This means,
  instead of ``tal:content="view/value"`` you must use
  ``tal:content="view.value"``. Every occurence of TAL-expressions
  starting with ``python:`` now can be shortened by skipping this
  marker.

* Also genshi-like variable substitutions are supported. For example
  you can write ``${myvar}`` instead of ``tal:content="myvar"``.

Beside this, most rules for regular Zope page templates apply also to
chameleon page templates.

See the `Chameleon`_ page for more information.

.. _Chameleon: http://chameleon.repoze.org/docs/latest/zpt.html

Prerequisites
-------------

Before we can see the templates in action, we care for correct
registration and set some used variables:

    >>> import os
    >>> testdir = os.path.dirname(__file__)
    >>> cpt_fixture = os.path.join(testdir, 'cpt_fixture')
    >>> template_dir = os.path.join(cpt_fixture, 'app_templates')

We create a mammoth, which should provide us a bunch of chameleon page
template driven views and put it in the database to setup location
info::

    >>> from dolmen.template.tests.cpt_fixture.app import Mammoth
    >>> manfred = Mammoth()
    >>> manfred.__name__ = "manfred"

    >>> class View(object):
    ...     def __init__(self, context):
    ...         self.context = context
    ...
    ...     def namespace(self):
    ...         return {'view': self,
    ...                 'context': self.context}

    >>> view = View(manfred)

Simple templates
----------------

We prepared a plain cavepainting view. The template looks like this:

    >>> cavepainting_cpt = os.path.join(template_dir, 'cavepainting.cpt')
    >>> print open(cavepainting_cpt, 'rb').read()
    <html>
      <body>
        A cave painting.
      </body>
    </html>

The rendered view looks like this:

    >>> from dolmen.template.components import PageTemplate
    >>> template = PageTemplate(filename=cavepainting_cpt)

    >>> print template.render(view)
    <html>
      <body>
        A cave painting.
      </body>
    </html>

Substituting variables
----------------------

A template can access variables like ``view``, ``context`` and its
methods and attributes. The ``food`` view does exactly this. The
template looks like this:

    >>> food_cpt = os.path.join(template_dir, 'food.cpt')
    >>> print open(food_cpt, 'rb').read()
    <html>
    <body>
    <span tal:define="foo 'a FOO'">
    ${view.me_do()}
    <span tal:replace="structure view.me_do()" />
    CSS-URL: ${static['test.css']()}
    My context is: ${view.url(context)}
    ${foo}
    <span tal:replace="foo" />
    </span>
    </body>
    </html>

The rendered view looks like this:

    >>> template = PageTemplate(filename=food_cpt)
    >>> print template.render(view)
    <html>
    <body>
    <span>
    &lt;ME GROK EAT MAMMOTH!&gt;
    <ME GROK EAT MAMMOTH!>
    CSS-URL: http://127.0.0.1/@@/dolmen.template.tests.cpt_fixture/test.css
    My context is: http://127.0.0.1/manfred
    a FOO
    a FOO
    </span>
    </body>
    </html>

As we can see, there is a difference between Genshi-like substitution
and TAL-like substitution: while both expressions::

  ${view.me_do()}

and::

  <span tal:replace="view.me_do()" />

actually render the same string ``<ME GROK EAT MAMMOTH!>``, the former
does this straight and plain, while the latter performs additionally
HTML-encoding of the string. Therefore the output of both expressions
differ. It's::

  <ME GROK EAT MAMMOTH!>

for the former expression and::

  &lt;ME GROK EAT MAMMOTH!&gt;

for the latter.


Inline Templates
----------------

We can also define inline templates. In our ``app.py`` we defined an
inline template like this::

  from dolmen.template import components

  ...

  inline = components.PageTemplate(
      "<html><body>ME GROK HAS INLINES! ${view.__class__}</body></html>")

If we render this view we get:

   >>> from dolmen.template.tests.cpt_fixture.app import inline
   >>> print inline.render(view)
   <html><body>ME GROK HAS INLINES! Some Text</body></html>


Macros
------

With ``dolmen.template`` we can also use macros, although it is a bit
different from regular Zope page templates.

We can define macros like this:

    >>> cpt_file = os.path.join(template_dir, 'macromaster.cpt')
    >>> print open(cpt_file, 'rb').read()
    <p xmlns:metal="http://xml.zope.org/namespaces/metal"
       metal:define-macro="hello">
      Hello from <b metal:define-slot="name">macro master</b>
    </p>

The defined macro ``hello`` can be rendered in another Chameleon
template with the METAL attribute ``use-macro``.

To refer to a local macro, i.e. a macros defined in the same template,
you can use something like::

  <div metal:use-macro="template.macros['<macro-name>']">
    Replaced by macro
  </div>

where ``<macro-name>`` must be an existing macro name.

To refer to macros in external templates, you must use the ``path:``
expression like this::

  <div metal:use-macro="path:
    context/@@<viewname>/template/macros/<macro-name>">
     Replaced by external macro
  </div>

where ``<viewname>`` refers to an existing view on ``context`` and
``macro-name`` again refers to an existing macro in the specified template.

Note, that this is different from how you refer to macros in standard
Zope page templates. The short notation ``view/macros/<macro-name>``
works only with regular Zope page templates.

The following template makes use of both methods:

    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')
    >>> print open(cpt_file, 'rb').read()
    <html xmlns:metal="http://xml.zope.org/namespaces/metal">
    <body>
      <p metal:define-macro="hello">
        Hi there from macro user!
      </p>
      <div metal:use-macro="template.macros['hello']">
        Fill this
      </div>
    <BLANKLINE>
      <div metal:use-macro="path: context/@@macromaster/template/macros/hello">
        <b metal:fill-slot="name">user slot</b>
        Fill this too
      </div>
    </body>
    </html>

When rendered also the slot defined in the master template is filled
by macro user content:

    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')
    >>> view = getMultiAdapter((manfred, request), name='macrouser')
    >>> print view()
    <html>
    <body>
      <p>
        Hi there from macro user!
      </p>
      <p>
        Hi there from macro user!
      </p>
    <BLANKLINE>
    <BLANKLINE>
      <p>
      Hello from <b>user slot</b>
    <BLANKLINE>
    </p>
    </body>
    </html>


Text templates
--------------

Also genshi text templates are supported. We have a template that
looks like so:

    >>> hunter_cgt = os.path.join(template_dir, 'hunter.cgt')
    >>> print open(hunter_cgt, 'rb').read()
    ME GROK HUNT ${view.game}!

Note, that this template has the ``.cgt`` (= **c**\ ameleon **g**\ enshi
**t**\ ext template) file extension.

If we render it, all expressions are substituted:

    >>> view = getMultiAdapter((manfred, request), name='hunter')
    >>> print view()
    ME GROK HUNT MAMMOTH!!



Differences from regular Zope page templates
--------------------------------------------

* Macros are referenced differently. See appropriate section above.

* Expressions are parsed in ``Python-mode`` by default. This means,
  instead of ``tal:content="view/value"`` you must use
  ``tal:content="view.value"``. Every occurence of TAL-expressions
  starting with ``python:`` now can be shortened by skipping this
  marker.
